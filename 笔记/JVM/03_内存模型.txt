
由于计算机的存储设备与处理器的运算能力之间有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽
可能接近处理器运算速度的高速缓存(cache)来作为内存与处理器之间的缓冲。将运算需要使用到的数据复制到缓存中，
让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无需等待缓慢的内存读写了。

基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是引入了一个新的问题: 缓存一致性(Cache Coherence)。
在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主存，多个处理器运算任务都涉及同一块主存，
需要一种协议可以保障数据的一致性，这类协议有MSI、MESI、MOSI及Dragon Protocol等。

JVM内存模型中定义的内存访问操作与硬件的缓存访问操作是具有可比性的。


Java内存模型(Java Memory Model，JMM)

JVM规范中试图定义一种Java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下
都能达到一致的内存访问效果。

Java内存模型(Java Memory Model)描述了Java程序中各种变量(线程共享变量)的访问规则,以及在JVM中将变量存储到
内存和从内存中读取出变量这样的底层细节。
(这里说的变量包括实例字段、静态字段和构成数组对象的元素，不包括局部变量与方法参数，因为后者是线程私有的，
不会共享，也就不存在竞争的问题。)

Java内存模型规定:
1.所有的变量都存储在主内存(Main Memory)中;
2.每个线程都有自己独立的工作内存(Work Memory，可以与前面讲的处理器的高速缓存类比)，里面保存该线程使用到的
变量的副本(主内存中该变量的一份拷贝);
3.线程对共享变量的所有操作(读取、赋值等)都必须在自己的工作内存中进行，不能直接从主内存中读写;
4.不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。

-----------------------------------------------------------------------------------------------------------
内存间的交互动作:

lock(锁定)
作用于主内存变量，把一个变量标示为一条线程独占的状态

unlock(解锁)
作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定

read(读取)
作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用

load(载入)
作用于工作内存的变量，把read操作从主存中得到的变量值放入工作内存的变量副本中

use(使用)
作用于工作内存的变量，把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的
字节码指令时将会执行这个操作

assign(赋值)
作用于工作内存的变量，把一个从执行引擎接收到的值赋给工作内存中的变量，每当虚拟机遇到一个给变量赋值的
字节码指令时执行这个操作

store(存储)
作用于工作内存的变量，把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用

write(写入)
作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中

Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。

-----------------------------------------------------------------------------------------------------------
Java内存模型中的可见性、原子性和有序性。

1.可见性

通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个
线程之间对内存写入操作的可见性，必须使用同步机制。

可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。另一个线
程马上就能看到。比如: 用volatile修饰的变量，就会具有可见性。

volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一
个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0; 之后有一
个操作 a++; 这个变量a具有可见性，但是 a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。

在 Java 中, volatile、synchronized 和 final 实现可见性。　　

2.原子性

原子是世界上的最小单位，具有不可分割性。比如 int a=0; 这个操作是不可分割的，那么我们说这个操作时原子操作。
再比如: a++; 这个操作实际是 a=a+1; 是可分割的，所以它不是一个原子操作。非原子操作都会存在线程安全问题，
需要我们使用同步技术(synchronized)来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。

java的concurrent包下提供了一些原子类，比如: AtomicInteger、AtomicLong、AtomicReference等。

在 Java 中, synchronized 和 lock&unlock 保证原子性。

3.有序性

Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性。
volatile 是因为其本身包含 "禁止指令重排序" 的语义，synchronized 是由 "一个变量在同一个时刻只允许一条线程
对其进行 lock 操作" 这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。

-----------------------------------------------------------------------------------------------------------
JVM内存分区: Java栈、堆、方法区、本地方法栈、程序计数器。

1.程序计数器
程序计数器是当前线程所执行字节码的行号指示器，所以它是私有的。如果线程执行的是非native方法，则程序计数器中
保存的是当前需要执行的指令的地址；如果线程执行的是native方法，则程序计数器中的值是undefined。程序计数器是
不会发生内存溢出现象(OutOfMemory)的。

2.Java栈(Java虚拟机栈)
Java栈与线程的生命周期相同，java栈中存放的是一个个栈帧。栈帧中存放的是局部变量表、操作数栈、指向运行时常量
池的引用、方法返回值地址和附加信息。也就是当jvm创建一个线程时，Java栈也随之创建(因此它也是线程私有)，线程
执行一个方法时就会创建一个栈与之对应的帧并压入栈中，方法执行结束，栈帧出栈。
局部变量表: 这里面存放的是方法中的局部变量(方法中声明的非静态变量以及形参和returnAddress类型)。局部变量表
的大小在编译时期就完成分配，方法运行期间大小不会改变。

3.本地方法栈
为Native方法服务。

4.Java堆
虚拟机启动时创建，线程共享，用于存储数组以及对象。(-Xmx和-Xms控制)

5.方法区(非堆)
存储常量、静态变量、已经被虚拟机加载的类信息(包括类的名称、方法信息、字段信息)等。
(对应JVM内存配置中的-PermSize等)

-----------------------------------------------------------------------------------------------------------
内存屏障分为4种类型:

1.LoadLoad屏障:
对于这样的语句 Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。

2.StoreStore屏障:
对于这样的语句 Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。

3.LoadStore屏障:
对于这样的语句 Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。

4.StoreLoad屏障:
对于这样的语句 Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销
是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。

